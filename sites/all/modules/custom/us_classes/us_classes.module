<?php
/**
 * @file
 * Code for the us_classes feature.
 */

include_once 'us_classes.features.inc';

/**
 * Implements hook_menu().
 */
function us_classes_menu() {
  $items['classes/add'] = array(
    'title' => '+ Submit a new proposal',
    'page callback' => 'us_classes_add',
    'access callback' => TRUE,
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );

  return $items;
}

/**
 * Menu callback: redirect to add page.
 */
function us_classes_add() {
  if (php_sapi_name() == 'cli' || preg_match('/\/cron.php$/', $_SERVER['SCRIPT_NAME']) || current_path() == 'admin/reports/status/run-cron') {
    drupal_access_denied();
  }
  drupal_goto('node/add/class');
}

/**
 * Implements hook_theme().
 */
function us_classes_theme($existing, $type, $theme, $path) {
  return array(
    'us_classes_involvement_user' => array(
      'variables' => array(
        'user' => NULL,
        'involvement' => NULL,
      ),
    ),
  );
}

/**
 * Implements hook_field_access().
 *
 * Note field_permissions module is overkill here.
 */
function us_classes_field_access($op, $field, $entity_type, $entity, $account) {
  $is_committee = in_array('committee', $account->roles);


  $fields = array('field_status', 'field_dates');
  if (in_array($field['field_name'], $fields) && $op == 'edit') {
    return $is_committee;
  }

  return TRUE;
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 */
function us_classes_field_widget_multiple_selects_form_alter(&$element, &$form_state, $context) {
  // Sort the facilitators values, because they are altered post-sort by
  // theme_username(). This makes facilitators easier to find in the list.
  if ($context['instance']['field_name'] == 'field_facilitators') {
    if (isset($element['target_id']['#options'])) {
      asort($element['target_id']['#options']);
    }
  }
}

/**
 * Implements hook_block_info().
 *
 * @todo Remove this when hook_user_view() bus is fixed.
 */
function us_classes_block_info() {
  // This example comes from node.module.
  $blocks['user_classes_involvement'] = array(
    'info' => t('Classes involved in'),
//    'cache' => DRUPAL_NO_CACHE
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 *
 * @todo Remove this when hook_user_view() bus is fixed.
 */
function us_classes_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'user_classes_involvement':
      if ($account = menu_get_object('user')) {
        $block['subject'] = t('Classes involved in');
        $block['content'] = us_classes_user_classes_involvement_render($account);
      }
      break;
  }
  return $block;
}

/**
 * Implements hook_node_view().
 */
function us_classes_node_view($node, $view_mode, $langcode) {
  switch ($node->type) {
    case 'class':
      $build = array();
      if ($view_mode == 'full') {
        $build['title'] = array(
          '#markup' => '<h2>' . t('Class involvement') . '</h2>',
        );
      }
      $build['content'] = us_classes_involvement_render($node, $view_mode);
      $node->content['us_classes_involvement'] = $build;
      break;
  }
}

/**
 * Implements hook_user_view().
 *
 * @todo Why is this not displaying?
 */
function us_classes_user_view($account, $view_mode, $langcode) {
//  $build = array();
//  $build['title'] = array(
//    '#markup' => '<h2>' . t('Classes involved in') . '</h2>',
//  );
//  $build['classes'] = us_classes_user_classes_involvement_render($account);
//  $rendered = drupal_render($build);
//  $account->content['summary']['us_classes_user_classes_involvement'] =  array(
//    '#type' => 'user_profile_item',
//    '#title' => t('Classes involved in'),
//    '#markup' => $rendered,
//    '#attributes' => array('class' => array('classes')),
//  );
}

/**
 * Implements hook_field_extra_fields().
 */
function us_classes_field_extra_fields() {
  $extra['node']['class']['display'] = array(
    'us_classes_involvement' => array(
      'label' => t('Class involvement'),
      'description' => t('A list of users involved with the class.'),
      'weight' => 10,
    ),
  );
//  $extra['user']['user']['display'] = array(
//    'us_classes_user_classes_involvement' => array(
//      'label' => t('Class involvement'),
//      'description' => t('A list of classes this user is involved with.'),
//      'weight' => 10,
//    ),
//  );
  return $extra;
}

/**
 * Renders a list of classes the user is involved in.
 *
 * @param $account
 *
 * @return array
 *   A Drupal render array - either a list of nodes, or empty text.
 */
function us_classes_user_classes_involvement_render($account) {
  $entity_type = 'node';
  $bundle = 'class';
  $field_name = 'field_facilitators';
  $ids = array();

  // Find classes this user proposed.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', $entity_type)
    ->entityCondition('bundle', $bundle)
    ->propertyCondition('uid', $account->uid)
    ->execute();
  if (isset($result[$entity_type])) {
    $ids = array_merge($ids, array_keys($result[$entity_type]));
  }

  // Find classes this user is facilitating.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', $entity_type)
    ->entityCondition('bundle', $bundle)
    ->fieldCondition($field_name, 'target_id', $account->uid)
    ->execute();
  if (isset($result[$entity_type])) {
    $ids = array_merge($ids, array_keys($result[$entity_type]));
  }

  // Find classes this user has flagged.
  $flags = flag_get_user_flags('node', NULL, $account->uid);
  $flag_name = 'subscribe_class';
  if (isset($flags[$flag_name])) {
    $ids = array_merge($ids, array_keys($flags[$flag_name]));
  }

  // Remove duplicates.
  $ids = array_unique($ids);

  // Order by title here as opposed to the query, because we are merging two
  // query results together.
  $nodes = node_load_multiple($ids);
  $keyed = array();
  foreach ($nodes as $node) {
    $keyed[drupal_html_class(check_plain($node->title))] = $node;
  }
  ksort($keyed);
  // Reset to their original IDs so _field_invoke_multiple() doesn't freak.
  $rekeyed = array();
  foreach ($keyed as $node) {
    $rekeyed[$node->nid] = $node;
  }

  if (!empty($ids)) {
    $output = node_view_multiple($rekeyed);
  }
  else {
    $output = array(
      '#markup' => '<div class="alert alert-warning">' . t('This person is not involved in any classes yet.') . '</div>',
    );
  }

  return $output;
}

/**
 * Includes the node author in the list of facilitators.
 *
 * @param object $node
 *   The node object.
 */
function us_classes_add_author_as_facilitator($node) {
  try {
    $wrapper = entity_metadata_wrapper('node', $node);
    $field_name = 'field_facilitators';
    $included = ($values = $wrapper->$field_name->raw()) && in_array($node->uid, $values) ? TRUE : FALSE;
    if (!$included) {
      $values[] = $node->uid;
      $wrapper->$field_name->set($values);
      $wrapper->save();
    }
  }
  catch(\EntityMetadataWrapperException $e) {
    // Do nothing. If this fails we have done something wrong.
  }
}

/**
 * Function to render the class involvement list of users.
 *
 * Note we're not making a view mode on profile2 (we could, but we'd be
 * repeating the query we need to do here anyway for sorting). And views would
 * be overkill here, since we want each user's item to include reverse
 * entity references, node authorship, and later flags (for interest) - and sort
 * the list by those as well.
 *
 * @param object $node
 *   The class node object.
 * @param string $view_mode
 *   The node view mode.
 *
 * @return array
 *   A render array for the class involvement list.
 */
function us_classes_involvement_render($node, $view_mode = 'teaser') {
  try {
    $wrapper = entity_metadata_wrapper('node', $node);

    // Start the list of users involved in the class.
    $list = array();

    // @todo Consider supporting a multiple proposers field (for when a group
    //   arrives at an idea together). For now, only the node author is
    //   listed as having proposed the class.
    $uid = $wrapper->author->uid->value();
    $list[$uid][] = t('Proposed');

    // Find the users who are helping to organize the class (facilitating). Add
    // them to the list if they're not already (either way, add 'facilitating'
    // to the user's level of participation comma-separated list.
    $field_name = 'field_facilitators';
    $uids = $wrapper->$field_name->raw();
    foreach ($uids as $uid) {
      $list[$uid][] = t('Facilitating');
    }

    // Find the users who are interested in the class, and add them too.
    $flag_options = array(
      'facilitate' => t('Offered to help facilitate'),
      'organize' => t('Offered to help organize'),
      'follow' => t('Following'),
    );
    $flag_name = 'subscribe_class';
    $flags = flag_get_entity_flags('node', $node->nid, $flag_name);
    $flag_count = 0;
    foreach ($flags as $data) {
      // Decide whether to show details of this flag, or add to a 'more' count.
      $details = FALSE;
      // Users should always see their own flag details.
      global $user;
      if ($data->uid == $user->uid) {
        $details = TRUE;
      }
      // Display account flag details when viewing that user's account.
      if (($account = menu_get_object('user')) && $data->uid == $account->uid) {
        $details = TRUE;
      }
      if ($view_mode == 'full') {
        $details = TRUE;
      }

      // Load user-specific flag logic only when we need to.
      if ($details) {
        // The user may have forgotten to click 'following', but still has the
        // involved flag. Consider making 'following' mandatory for this flag,
        // but for now make sure to display that option.
        $list[$data->uid][] = $flag_options['follow'];

        // Overwrite the default if there are flagging form items on this flag.
        $flag = flag_get_flag(NULL, $data->fid);
        $flagging = $flag->get_flagging($node->nid, $data->uid);
        if ($flagging && $items = field_get_items('flagging', $flagging, 'field_interest')) {
          foreach ($items as $item) {
            // Map to strings.
            $list[$flagging->uid][] = $flag_options[$item['value']];
          }
        }
      }
      // Don't load user-specific flag logic if we don't need it.
      else {
        // Increment for a 'more' count instead.
        $flag_count ++;
      }
    }

    // Pass to a theme function, to wrap the user class involvement info in
    // markup that we can style.
    $build = array(
      '#type' => 'container',
      '#attributes' => array(
        'class' => array('class-involvement'),
        'id' => 'class-involvement-' . $node->nid,
      ),
    );

    // Anonymous user 'get involved' link. Note we don't deal with the normal
    // flag here, because we output it as a field instead, and modify it's
    // placement in us_classes_entity_view_alter().
    if (user_is_anonymous()) {
      $build['flag_' . $flag_name] = us_classes_anonymous_get_involved_link();
    }

    // Loop over the list of users, and get the themed render array.
    foreach ($list as $uid => $involvement) {
      $variables = array(
        'user' => user_load($uid),
        'involvement' => array_unique($involvement),
      );
      $build[$uid] = theme('us_classes_involvement_user', $variables);
    }

    // On teasers just show a count of flags.
    if ($view_mode == 'teaser' && $flag_count > 0) {
      $build['more'] = array(
        '#markup' => '<span class="involved-more">' . format_plural($flag_count, '1 more person involved', '@count more people involved') . '</span>',
      );
    }

    return $build;
  }
  catch(\EntityMetadataWrapperException $e) {
    // Do nothing. If this fails we have done something wrong.
  }
}

/**
 * Implements hook_menu_alter().
 */
function us_classes_menu_alter(&$items) {
  $paths = array(
    'create' => 'flag/flagging/%flag/%content_id/create/inline',
    'edit' => 'flag/flagging/%flag/%content_id/edit/inline',
    'delete' => 'flag/flagging/%flag/%content_id/delete/inline',
  );
  foreach ($paths as $op => $path) {
    $items[$path]['page callback'] = 'us_classes_flagging_inline_edit_flagging';
    $items[$path]['page arguments'][] = $op;
  }
}

/**
 * Menu callback.
 *
 * Wrapper around flagging_inline_edit_flagging(), allowing us to including
 * additional ajax framework commands. Specifically, we refresh the
 * 'Class involvement' element after submitting a class subscription flag.
 */
function us_classes_flagging_inline_edit_flagging($flag, $content_id, $op) {
  // Keep initial functionality, but add to the ajax commands returned by
  // flagging_inline_edit_flagging(). Note we don't just call that function
  // because we need the form state to see whether it has been executed (before
  // adding our custom commands), so we should not do all that logic twice.
  $flagging = $flag->get_flagging($content_id);
  if (!$flagging) {
    // New flagging.
    $flagging = $flag->new_flagging($content_id);
  }
  $form_state = array(
    'no_redirect' => TRUE,
    // Tell our hook_form_alter() to kick in.
    'flag_is_using_inline' => TRUE,
    'flag_suppress_messages' => TRUE,
    'build_info' => array(
      'args' => array($flagging),
    ),
  );
  // Do this to keep a single function (DRY).
  $form_id = $op == 'delete' ? 'flagging_form_flagging_delete_form' : 'flagging_form_flagging_form';
  $form = drupal_build_form($form_id, $form_state);
  $result = flagging_inline_process_form_result($form, $form_state, $flag, $content_id);

  if (!empty($form_state['executed'])) {
    $node = node_load($content_id);

    // Get the view mode we want to render (teaser only includes the important
    // players). Sadly, there is not a good way to get the path from here
    // because it's an ajax callback. Let's try for the referrer.
    $view_mode = 'teaser';
    if (isset($_SERVER['HTTP_REFERER'])) {
      $url = parse_url($_SERVER['HTTP_REFERER']);
      // parse_url() path includes a preceeding slash.
      $path = drupal_get_normal_path(trim($url['path'], '/'));
      if (arg(0, $path) == 'node' && is_numeric(arg(1, $path))) {
        $view_mode = 'full';
      }
    }

    $build = us_classes_involvement_render($node, $view_mode);
    $html = drupal_render($build);

    // Note we set this element ID pattern in us_classes_involvement_render().
    $selector = 'class-involvement-' . $content_id;

    // Add to the existing commands.
    $result['#commands'][] = ajax_command_replace("#{$selector}", $html);
    $result['#commands'][] = ajax_command_changed("#{$selector}");
  }

  return $result;
}

/**
 * Returns HTML for a foo.
 *
 * @param array $variables
 *   An associative array containing:
 *   - user: A user object that is being formatted.
 *   - involvement: An array of strings describing the user's involvement. These
 *     should be sanitized before being passed here.
 *
 * @ingroup themeable
 *
 * @return array
 *   A Drupal render array for the class involvement section markup.
 */
function theme_us_classes_involvement_user($variables) {
  $user = $variables['user'];
  $involvement = $variables['involvement'];

  $build = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('user-involved'),
    ),
  );

  $build['avatar'] = array(
    '#markup' => theme('user_picture', array('account' => $user, 'user_picture_style' => 'tiny')),
  );

  $build['name'] = array(
    '#markup' => theme('username', array('account' => $user)),
    '#prefix' => '<span class="user-name">',
    '#suffix' => '</span>',
  );

  $build['involvement'] = array(
    '#markup' => implode(', ', $involvement),
    '#prefix' => '<span class="user-involvement">',
    '#suffix' => '</span>',
  );

  return $build;
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 */
function us_classes_field_widget_options_buttons_form_alter(&$element, &$form_state, $context) {
  if ($context['instance']['entity_type'] == 'flagging' && $context['instance']['field_name'] == 'field_interest') {
    if (isset($element['#title'])) {
      // The title is redundant on the interest field, since flag_inline unflag
      // provides us with an option more consistent with the 'Add me' toggle.
      $element['#title'] = '';
    }
  }
}

/**
 * Implements hook_entity_view_alter().
 *
 * @see flag_entity_view()
 */
function us_classes_entity_view_alter(&$build, $type) {
  // Modify the class subscribe flag markup, if users can access it.
  if ($type == 'node' && $build['#view_mode'] == 'full' && ($flag_name = 'subscribe_class') && $flag = flag_get_flag($flag_name)) {
    $entity = $build['#node'];
    // Short circuits some of the checks below - if this is not in the render
    // array, we don't need to do any of the checks (performance increase).
    if (isset($build['flag_' . $flag_name])) {
      // @see flag_entity_view()
      if (!($flag->show_as_field)) {
        return;
      }
      $entity_id = $flag->get_entity_id($entity);
      if (is_null($entity_id)) {
        $entity_id = 'new';
      }
      // Do this access check anyway, to be on the safe side.
      $flag->remember_entity($entity_id, $entity);
      if (!$flag->access($entity_id) && (!$flag->is_flagged($entity_id) || !$flag->access($entity_id, 'flag'))) {
        return;
      }
      if ($flag->show_as_field) {
        // The flag is shown. Do our magic here.
        // Swap labels with the class involvement field, so this flag will
        // display below the header.
        $build['flag_' . $flag_name]['#prefix'] = '<h2>Class involvement</h2>';
        $build['us_classes_involvement']['title']['#markup'] = '';
      }
    }
  }
}

/**
 * Outputs get involved link for anonymous users.
 *
 * @return array
 *   Render array anonymous get involved link.
 */
function us_classes_anonymous_get_involved_link() {
  return array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('flag-outer-subscribe-class'),
    ),
    'link' => array(
      '#theme' => 'link',
      '#text' => '+ Get involved',
      '#path' => 'user/login',
      '#options' => array(
        'attributes' => array('class' => array('flag'), 'id' => 'flag-anonymous-involvement'),
        // Required.
        'html' => FALSE,
        'query' => drupal_get_destination(),
      ),
    ),
  );
}

